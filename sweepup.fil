import "primitives/core.fil";
import "examples/sequential.fil";
import "primitives/math/math.fil";

comp main<'G:5>(
  go: interface['G],
  in0: ['G, 'G+5] 32,
  in1: ['G, 'G+5] 32,
  in2: ['G, 'G+5] 32,
  in3: ['G, 'G+5] 32,
  in4: ['G, 'G+5] 32,
  in5: ['G, 'G+5] 32,
  in6: ['G, 'G+5] 32,
  in7: ['G, 'G+5] 32,
) -> (
  out0: ['G+4, 'G+5] 32,
  out1: ['G+4, 'G+5] 32,
  out2: ['G+4, 'G+5] 32,
  out3: ['G+4, 'G+5] 32,
  out4: ['G+4, 'G+5] 32,
  out5: ['G+4, 'G+5] 32,
  out6: ['G+4, 'G+5] 32,
)
{
  // Pack the inputs (which arrive on separate wires) into a single bundle
  // The input bundle lives for 1 cycle (start -> start + 1 cycle)
  bundle input_bundle[8]: ['G, 'G+5] 32;
  input_bundle{0} = in0;
  input_bundle{1} = in1;
  input_bundle{2} = in2;
  input_bundle{3} = in3;
  input_bundle{4} = in4;
  input_bundle{5} = in5;
  input_bundle{6} = in6;
  input_bundle{7} = in7;

  // Generate the first layer
  // To be concise, I have just created a bundle of size 8 and scheduled to do pairwise additions on the adders
  // We only need the results at even numbered indices since we want the operands to be exclusive (Filament only allows single increments)
  bundle first_layer[8]: ['G+1, 'G+5] 32;

  // This is pipelined and takes only a cycle to evaluate!
  for i in 0..7 {
    a := new Add[32]<'G>(input_bundle{i}, input_bundle{i + 1});
    r0 := new Register[32]<'G, 'G+5>(a.out);
    first_layer{i} = r0.out;
  }

  // Set the last value manually to avoid indexing problems
  a := new Add[32]<'G>(input_bundle{6}, input_bundle{7});
  r0 := new Register[32]<'G, 'G+5>(a.out);
  first_layer{7} = r0.out;

  // Create the bundle for the second layer
  // Add using the operands from the first layer
  bundle second_layer[2]: ['G+3, 'G+5] 32;

  a_1 := new Add[32]<'G + 2>(first_layer{0}, first_layer{2});
  r1 := new Register[32]<'G+2, 'G+5>(a_1.out);
  second_layer{0} = r1.out;

  a_2 := new Add[32]<'G + 2>(first_layer{4}, first_layer{6});
  r2 := new Register[32]<'G+2, 'G+5>(a_2.out);
  second_layer{1} = r2.out;

  bundle third_layer[1]: ['G+4, 'G+5] 32;
  // Repeat again for the top most element
  a_3 := new Add[32]<'G + 3>(second_layer{0}, second_layer{1});
  r3 := new Register[32]<'G+3, 'G+5>(a_3.out);

  third_layer{0} = r3.out;

  bundle left_subtree_sums[7]: ['G+4, 'G+5] 32;
  for i in 0..log2(8) {
    if i == 0 {
      left_subtree_sums{0} = second_layer{0};
    }
    if i == 1 {
      left_subtree_sums{1} = first_layer{0};
      left_subtree_sums{2} = first_layer{4};
    }
    if i == 2 {
      left_subtree_sums{3} = input_bundle{0};
      left_subtree_sums{4} = input_bundle{2};
      left_subtree_sums{5} = input_bundle{4};
      left_subtree_sums{6} = input_bundle{6};
    }
  }
  out0 = left_subtree_sums{0};
  out1 = left_subtree_sums{1};
  out2 = left_subtree_sums{2};
  out3 = left_subtree_sums{3};
  out4 = left_subtree_sums{4};
  out5 = left_subtree_sums{5};
  out6 = left_subtree_sums{6};

}